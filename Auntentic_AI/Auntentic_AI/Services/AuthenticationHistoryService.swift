//
//  AuthenticationHistoryService.swift
//  Auntentic_AI
//
//  Created by Claude AI on 12/30/25.
//  Task 13: Service for saving authentication results to Supabase database
//

import Foundation
import Supabase
import OSLog

/// Service for managing authentication history in Supabase database
@Observable
final class AuthenticationHistoryService {

    // MARK: - Properties

    /// Saved authentication record
    var savedRecord: AuthenticationRecord?

    /// Last error
    var lastError: Error?

    private let logger = Logger(subsystem: "com.checkkicks.app", category: "AuthHistory")
    private let supabase = SupabaseClientManager.shared

    // MARK: - Database Models

    /// Database record for authentications table
    struct AuthenticationRecord: Codable {
        let id: UUID?
        let userId: UUID
        let createdAt: Date?
        let verdict: String
        let confidence: Int
        let observations: [String]
        let imageUrls: [String]
        let sneakerModel: String?

        enum CodingKeys: String, CodingKey {
            case id
            case userId = "user_id"
            case createdAt = "created_at"
            case verdict
            case confidence
            case observations
            case imageUrls = "image_urls"
            case sneakerModel = "sneaker_model"
        }
    }

    // MARK: - Save Methods

    /// Save authentication result to database
    /// - Parameters:
    ///   - result: Authentication result from OpenAI Vision API
    ///   - imageUrls: Uploaded image URLs from Supabase Storage
    ///   - sneakerModel: Optional sneaker model name
    /// - Returns: Saved authentication record with generated ID
    @MainActor
    func saveAuthentication(
        result: AuthenticationResult,
        imageUrls: [URL],
        sneakerModel: String? = nil
    ) async throws -> AuthenticationRecord {
        logger.info("üíæ Saving authentication result to database...")

        do {
            // Get authenticated user ID
            guard let session = try? await supabase.auth.session else {
                logger.error("‚ùå No active session found")
                throw AuthHistoryError.noActiveSession
            }

            let userId = session.user.id
            logger.info("üîë User ID: \(userId)")

            // Prepare record for database
            // Note: Database column "verdict" stores confidence level (high/moderate/low)
            // for legal compliance - we no longer use authentic/fake terminology
            let record = AuthenticationRecord(
                id: nil, // Will be auto-generated by database
                userId: userId,
                createdAt: nil, // Will be set by database DEFAULT now()
                verdict: result.confidenceLevel.rawValue, // "high", "moderate", or "low"
                confidence: result.confidenceScore,
                observations: result.observations,
                imageUrls: imageUrls.map { $0.absoluteString },
                sneakerModel: sneakerModel
            )

            logger.info("üìã Record prepared:")
            logger.info("  - Confidence Level: \(record.verdict)")
            logger.info("  - Confidence Score: \(record.confidence)%")
            logger.info("  - Observations: \(record.observations.count) items")
            logger.info("  - Images: \(record.imageUrls.count) URLs")

            // Insert into database
            let insertedRecord: AuthenticationRecord = try await supabase
                .from("authentications")
                .insert(record)
                .select()
                .single()
                .execute()
                .value

            await MainActor.run {
                self.savedRecord = insertedRecord
                logger.info("‚úÖ Authentication saved to database with ID: \(insertedRecord.id?.uuidString ?? "unknown")")
            }

            return insertedRecord

        } catch {
            await MainActor.run {
                self.lastError = error
                logger.error("‚ùå Failed to save authentication: \(error.localizedDescription)")
            }
            throw error
        }
    }

    /// Reset service state
    @MainActor
    func reset() {
        savedRecord = nil
        lastError = nil
        logger.info("üîÑ Authentication history service reset")
    }

    // MARK: - Fetch Methods

    /// Fetch authentication history for current user
    /// - Parameters:
    ///   - limit: Maximum number of records to fetch (default 20)
    ///   - offset: Number of records to skip for pagination (default 0)
    /// - Returns: Array of authentication records ordered by date descending
    @MainActor
    func fetchHistory(limit: Int = 20, offset: Int = 0) async throws -> [AuthenticationRecord] {
        logger.info("üìú Fetching authentication history (limit: \(limit), offset: \(offset))...")

        do {
            // Verify user is authenticated
            guard let session = try? await supabase.auth.session else {
                logger.error("‚ùå No active session for fetching history")
                throw AuthHistoryError.noActiveSession
            }

            logger.info("üîë Fetching history for user: \(session.user.id)")

            // Query authentications table with pagination
            let records: [AuthenticationRecord] = try await supabase
                .from("authentications")
                .select()
                .order("created_at", ascending: false)
                .range(from: offset, to: offset + limit - 1)
                .execute()
                .value

            logger.info("‚úÖ Fetched \(records.count) authentication records")
            return records

        } catch let error as AuthHistoryError {
            self.lastError = error
            throw error
        } catch {
            logger.error("‚ùå Failed to fetch history: \(error.localizedDescription)")
            self.lastError = error
            throw AuthHistoryError.databaseError(error)
        }
    }

    /// Fetch total count of authentication records for current user
    @MainActor
    func fetchHistoryCount() async throws -> Int {
        logger.info("üî¢ Fetching history count...")

        do {
            guard (try? await supabase.auth.session) != nil else {
                throw AuthHistoryError.noActiveSession
            }

            // Fetch with count
            let response = try await supabase
                .from("authentications")
                .select("id", head: true, count: .exact)
                .execute()

            let count = response.count ?? 0
            logger.info("‚úÖ Total records: \(count)")
            return count

        } catch {
            logger.error("‚ùå Failed to fetch count: \(error.localizedDescription)")
            throw error
        }
    }
}

// MARK: - Authentication History Errors

enum AuthHistoryError: LocalizedError {
    case noActiveSession
    case databaseError(Error)

    var errorDescription: String? {
        switch self {
        case .noActiveSession:
            return "No active session. Please sign in again."
        case .databaseError(let error):
            return "Database error: \(error.localizedDescription)"
        }
    }
}
