# Task ID: 20.5

**Title:** Performance testing & optimization to meet PRD targets

**Status:** pending

**Dependencies:** 11, 13, 18, 19

**Priority:** medium

**Phase:** 1C - User Experience Features

**Description:** Profile app with Instruments and optimize to meet PRD performance target of <30 seconds total flow (FR-3.6)

**PRD Performance Targets:**
- Image upload: < 5 seconds (4 images, ~4MB total)
- AI analysis: < 20 seconds
- Total end-to-end flow: < 30 seconds (target), < 60 seconds (maximum)
- Crash-free rate: 99%+
- App launch time: < 2 seconds

**Details:**

**1. Set Up Performance Measurement**
- Add performance logging to critical paths
- Create `PerformanceMonitor` utility class
- Measure key operations:
```swift
let start = Date()
// Operation
let duration = Date().timeIntervalSince(start)
os_log(.info, "Operation took %.2f seconds", duration)
```

**2. Profile Image Compression**
- Target: < 2 seconds per image
- Current implementation in Task 8 (photo review)
- Test with Instruments → Time Profiler
- Optimize JPEG compression quality if needed
- Consider async compression:
```swift
Task.detached(priority: .userInitiated) {
    return compressedImage
}
```

**3. Profile Image Upload**
- Target: < 5 seconds for 4 images
- Test with real network conditions (not just WiFi)
- Use Network Link Conditioner:
  - Simulate 3G/4G/5G speeds
  - Test with poor network
- Consider parallel uploads instead of sequential
- Add upload progress tracking
- Implement retry logic with exponential backoff

**4. Profile Edge Function Latency**
- Target: < 20 seconds AI analysis
- Test actual OpenAI API response times
- Cannot optimize Edge Function code (Supabase managed)
- But can optimize:
  - Image URL generation (signed URLs)
  - Request payload size
  - Timeout handling

**5. Profile View Rendering**
- Use Instruments → SwiftUI template
- Identify expensive view redraws
- Check for:
  - Unnecessary @Published updates
  - Heavy computations in view body
  - Large image rendering
  - Inefficient List/ScrollView usage
- Add `.task` modifiers for async loading

**6. Memory Profiling**
- Use Instruments → Allocations
- Check for:
  - Image memory leaks
  - Retained view models
  - Large data structures
- Target: < 100 MB memory usage
- Test on low-memory device (iPhone SE)

**7. App Launch Optimization**
- Use Instruments → App Launch
- Minimize work in App init
- Defer heavy operations until after first frame
- Target: < 2 seconds to first interactive screen

**8. Test on Physical Devices**
- Test on iPhone SE (low-end device)
- Test on iPhone 15 Pro (high-end device)
- Test on various iOS versions (17.0+)
- Record actual timing measurements

**9. Network Condition Testing**
- Use Network Link Conditioner (Xcode)
- Test scenarios:
  - WiFi (fast)
  - 4G LTE (moderate)
  - 3G (slow)
  - Edge case: slow WiFi
  - Edge case: intermittent connection

**10. Implement Optimizations**
Based on profiling results, optimize:
- Image compression algorithm
- Upload parallelization
- View rendering efficiency
- Memory usage reduction
- Loading state improvements

**Test Strategy:**

**Performance Test Suite:**

**Test 1: Happy Path - Ideal Conditions**
- Device: iPhone 15 Pro
- Network: WiFi (100 Mbps)
- Measure: End-to-end flow (capture → upload → AI → result)
- Target: < 30 seconds
- Record: Actual timing

**Test 2: Low-End Device**
- Device: iPhone SE (2nd gen)
- Network: WiFi
- Measure: Same as Test 1
- Target: < 45 seconds
- Check: No UI lag or freezing

**Test 3: Poor Network**
- Device: iPhone 15
- Network: 3G simulation (Network Link Conditioner)
- Measure: Upload time specifically
- Target: < 15 seconds
- Verify: Retry logic works

**Test 4: Memory Stress**
- Device: Any
- Action: Complete 10 authentication flows in a row
- Measure: Memory usage over time
- Target: No memory leaks, < 150 MB peak
- Check: No crashes or slowdowns

**Test 5: Cold Start**
- Action: Force quit app, relaunch
- Measure: Time to first interactive screen
- Target: < 2 seconds
- Check: Smooth launch animation

**Instruments Profiling Checklist:**
- [ ] Run Time Profiler → identify CPU hotspots
- [ ] Run Allocations → identify memory leaks
- [ ] Run Leaks → verify no retain cycles
- [ ] Run Network → analyze upload/download patterns
- [ ] Run App Launch → optimize startup time
- [ ] Run SwiftUI → identify view rendering issues

**Optimization Checklist:**
- [ ] Image compression optimized
- [ ] Upload uses parallel requests if beneficial
- [ ] View rendering minimized (no expensive body computations)
- [ ] Memory leaks fixed
- [ ] App launch time < 2 seconds
- [ ] End-to-end flow < 30 seconds (ideal conditions)
- [ ] End-to-end flow < 60 seconds (3G conditions)
- [ ] No UI freezing during operations

**Documentation:**
Create `PERFORMANCE_METRICS.md` with:
- Baseline measurements (before optimization)
- Target measurements (PRD goals)
- Actual measurements (after optimization)
- Device/network test matrix
- Known bottlenecks and limitations

**Completion Criteria:**
- [ ] All performance tests pass
- [ ] End-to-end flow meets < 30s target on WiFi
- [ ] No memory leaks detected
- [ ] App launch < 2 seconds
- [ ] Performance metrics documented
- [ ] Instruments profiling completed
- [ ] Optimizations implemented where needed
- [ ] Physical device testing complete

**Notes:**
- Some delays (OpenAI API) are external and cannot be optimized
- Focus on what we CAN control: compression, upload, UI rendering
- Document acceptable ranges for user expectations
